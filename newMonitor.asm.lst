#### Labels
CMDPEEK01        = 0xC487
CMDPEEK02        = 0xC48E
CMDPEEKdone      = 0xC49F
CMD_DUMP         = 0xC5A1
CMD_EXEC         = 0xC52A
CMD_FILL         = 0xC551
CMD_HELP         = 0xC456
CMD_INFO         = 0xC44F
CMD_LOAD         = 0xC4D0
CMD_PEEK         = 0xC45D
CMD_POKE         = 0xC4A3
COMMA            = 0xC3C2
CommandList      = 0xC2E2
DUMP0            = 0xC5ED
DUMP1            = 0xC5F4
DUMP2            = 0xC60D
DUMP3            = 0xC631
DUMPascdot       = 0xC62A
DUMPspace        = 0xC64F
DoCommand        = 0xC042
Done             = 0xC822
ERR_END          = 0xC3BC
ERR_INVALID_BYTE = 0xC398
ERR_INVALID_WORD = 0xC3AA
ERR_NOT_ENOUGH   = 0xC3E6
ERR_NOT_IMPLEMENTED = 0xC368
ERR_TOO_MANY     = 0xC3CA
ERR_UNKNOWN      = 0xC380
EndOfCommandList = 0xC31A
ErrInvalidByte   = 0xC422
ErrInvalidCom    = 0xC42A
ErrInvalidWord   = 0xC436
ErrNotEnough     = 0xC448
ErrTooMany       = 0xC441
FC01             = 0xC027
FC02             = 0xC029
FILL1            = 0xC594
FNT01            = 0xC79A
FNT02            = 0xC7A7
FindNextToken    = 0xC78D
GetInput         = 0xC7A8
Inp01            = 0xC7C1
Inp02            = 0xC7D1
InpMain          = 0xC7AF
LOAD1            = 0xC508
Main             = 0xC00D
Next             = 0xC819
PB1              = 0xC765
PBY1             = 0xC670
PD01             = 0xC860
PD1              = 0xC6FF
PH1              = 0xC69F
PHdo             = 0xC6C5
PHletts          = 0xC6BD
PROMPT           = 0xC31A
PW1              = 0xC684
PW2              = 0xC691
ParseBad         = 0xC756
ParseBinary      = 0xC75C
ParseByte        = 0xC65D
ParseDecimal     = 0xC6F6
ParseGood        = 0xC759
ParseHex         = 0xC696
ParseWord        = 0xC671
PokeMore         = 0xC4B8
PrepInDone       = 0xC815
PrepInput        = 0xC7DD
PrepInput1       = 0xC7FD
PrepInput1b      = 0xC807
PrepInput2       = 0xC7E2
PrepInput2b      = 0xC7F3
PrintByte        = 0xC845
PrintCRLF        = 0xC831
PrintDigit       = 0xC854
PrintStr         = 0xC824
PrintStr1        = 0xC82F
PrintStr2        = 0xC826
PrintWord        = 0xC83C
STR_BACK         = 0xC415
STR_BYE          = 0xC40F
STR_CHK          = 0xC404
STR_COLON        = 0xC41C
STR_DUMP_HEAD    = 0xC31D
STR_HELP         = 0xC062
STR_INFO         = 0xC049
STR_OK           = 0xC3C5
STR_SEP          = 0xC41F
StrCompare       = 0xC817
Top              = 0xC000
UARTInit         = 0xC866
UARTRead         = 0xC871
UARTWrite        = 0xC87B
WriteWait        = 0xC87D

#### Defines
ACI_CONTROL      = 0xA000
ACI_DATA         = 0xA001
BUFFER           = 0x7E00
END_OF_INPUT     = 0x7F00
PIA_A_CTRL       = 0x8001
PIA_A_DATA       = 0x8000
PIA_B_CTRL       = 0x8003
PIA_B_DATA       = 0x8002
STACK            = 0x8000
TMP1             = 0x7F06
TMP2             = 0x7F08
TMP3             = 0x7F0A
VALUE_LOWER      = 0x7F04
VALUE_OVERFLOW   = 0x7F02
VALUE_UPPER      = 0x7F03
_CPU             = 6809

                  ; Version 1.0
                  
                  ; Memory Map
                  ;
                  ; 0000 - 7FFF RAM
                  ; 8000 - 8003 PIA
                  ; A000 - A001 UART
                  ; C000 - FFFF ROM
                  
                  ; PIA
                  .PIA_A_DATA = 0x8000  ; 100x_xxxx_xxxx_xx00
                  .PIA_A_CTRL = 0x8001  ; 100x_xxxx_xxxx_xx01
                  .PIA_B_DATA = 0x8002  ; 100x_xxxx_xxxx_xx10
                  .PIA_B_CTRL = 0x8003  ; 100x_xxxx_xxxx_xx11
                  ; TODO: bit breakdowns of control
                  
                  ; ACI
                  .ACI_CONTROL = 0xA000  ; 101x_xxxx_xxxx_xxx0
                  .ACI_DATA = 0xA001     ; 101x_xxxx_xxxx_xxx1
                  ; Write to control:
                  ;   I_TT_WWW_CC
                  ;   I =   0: receive interrupt disabled
                  ;         1: receive interrupt enabled
                  ;   T =  00: RTS=low, transmit interrupt disabled
                  ;        01: RTS=low, transmit interrupt enabled
                  ;        10: RTS=high, transmit interrupt disabled
                  ;        11: RTS=low, transmit a break, transmit interrupt disabled
                  ;   W = 000: 7E2
                  ;       001: 7O2
                  ;       010: 7E1
                  ;       011: 7O1
                  ;       100: 8N2
                  ;       101: 8N1
                  ;       110: 8E1
                  ;       111: 8O1
                  ;   C =  00: divide by 1
                  ;        01: divide by 16
                  ;        10: divide by 64
                  ;        11: master reset
                  ; Read from control:
                  ;  bit
                  ;   0 = 1: receive data register full (1 means you can read)
                  ;   1 = 1: transmit data register empty (1 means you can write)
                  ;   2 = 1: data carrier detect
                  ;   3 = 1: clear to send
                  ;   4 = 1: framing error
                  ;   5 = 1: receiver overrun
                  ;   6 = 1: parity error
                  ;   7 = 1: interrupt request
                  ;
                  ; For my environment: 0_00_101_01
                  ;   I =   0: Receive interrupts off
                  ;   T =  00: Transmit interrupt off
                  ;   W = 101: 8N1
                  ;   C =  01: Divide by 16 (115200)
                  
                  ; ROM vectors:
                  ; 0xFFF0:
                  ;    .word ????  ; FFF0: 6809 exceptions
                  ;    .word ????  ; FFF2: SWI3
                  ;    .word ????  ; FFF4: SWI2
                  ;    .word ????  ; FFF6: FIRQ
                  ;    .word ????  ; FFF8: IRQ
                  ;    .word ????  ; FFFA: SWI
                  ;    .word ????  ; FFFC: NMI
                  ;    .word ????  ; FFFE: RESET
                  
                  ._CPU = 6809
                  .STACK = 0x8000              ; Stack at the end of RAM
                  
                  .BUFFER = 0x7E00             ; 256 bytes for user input including ...
                  .END_OF_INPUT = 0x7F00       ; ... leading space and null terminator
                  
                  .VALUE_OVERFLOW = 0x7F02     ; Three bytes ...
                  .VALUE_UPPER = 0x7F03        ; ... for word ...
                  .VALUE_LOWER = 0x7F04        ; ... parsing
                  
                  .TMP1 = 0x7F06
                  .TMP2 = 0x7F08
                  .TMP3 = 0x7F0A
                  
                  ;0x4000:                     ; When compiled to RAM (development)
                  0xC000:                      ; When compiled to ROM
                  
                  Top:
C000: 10 CE 80 00      LDS    #STACK            ; Initialize the stack
C004: BD C8 66         JSR    UARTInit          ; Initialize the UART
C007: 8E C0 49         LDX    #STR_INFO         ; Print info ...
C00A: BD C8 24         JSR    PrintStr          ; ... to show we are starting
                  
                  Main:
C00D: 8E C3 1A         LDX    #PROMPT           ; Print the ...
C010: BD C8 24         JSR    PrintStr          ; ... input prompt
C013: BD C7 A8         JSR    GetInput          ; Get a line of input from the user
C016: BF 7F 00         STX    END_OF_INPUT      ; This is one past the terminating null
C019: BD C7 DD         JSR    PrepInput         ; Tokenize it
                  
C01C: 8E 7E 00         LDX    #BUFFER           ; Start at the beginning of the buffer
C01F: BD C7 8D         JSR    FindNextToken     ; Get the next token
C022: 27 E9            BEQ    Main              ; Blank line ... ignore
                  
C024: CE C2 E2         LDU    #CommandList      ; List of command names and functions
                  FC01:
C027: 1F 32            TFR    U,Y               ; For string-compare
                  FC02:
C029: A6 C0            LDA    ,U+               ; Move U ...
C02B: 26 FC            BNE    FC02              ; ... to next ...
C02D: 33 42            LEAU   2,U               ; ... entry in list
C02F: BD C8 17         JSR    StrCompare        ; Is this the command?
C032: 27 0E            BEQ    DoCommand         ; Yes ... do it
C034: 11 83 C3 1A      CMPU   #EndOfCommandList ; No ... have we checked all commands?
C038: 26 ED            BNE    FC01              ; No ... try the next one
C03A: 8E C3 80         LDX    #ERR_UNKNOWN      ; Print ...
C03D: BD C8 24         JSR    PrintStr          ; ... Unknown Command
C040: 20 CB            BRA    Main              ; Next command
                  DoCommand:
C042: 10 AE 5E         LDY    -2,U              ; Get the command function
C045: AD A4            JSR    ,Y                ; Execute the command
C047: 20 C4            BRA    Main              ; Back for more commands
                  
                  STR_INFO:
C049: 36 38 42 30 39 20 53 42 43 20 4D 6F 6E 69 74 6F 72 20 76 31 2E 30 0D 0A 00 .byte "68B09 SBC Monitor v1.0",13,10,0
                  
                  STR_HELP:
C062: 20 20 23 20 43 6F 6D 6D 65 6E 74 20 72 65 73 74 20 6F 66 20 6C 69 6E 65 2E 0D 0A .byte "  # Comment rest of line.",13,10
C07D: 20 20 23 20 43 61 73 65 20 64 6F 65 73 6E 27 74 20 6D 61 74 74 65 72 2E 20 43 6F 6D 6D 61 73 20 61 72 65 20 69 67 6E 6F 72 65 64 2E 0D 0A .byte "  # Case doesn't matter. Commas are ignored.",13,10
C0AB: 20 20 23 20 55 6E 64 65 72 73 63 6F 72 65 73 20 69 6E 20 76 61 6C 75 65 73 20 61 72 65 20 69 67 6E 6F 72 65 64 2E 0D 0A .byte "  # Underscores in values are ignored.",13,10
C0D3: 20 20 23 20 44 65 63 69 6D 61 6C 3A 20 33 32 20 20 48 65 78 3A 20 30 78 46 41 43 45 20 20 42 69 6E 61 72 79 3A 20 30 62 31 31 30 30 31 31 31 31 0D 0A .byte "  # Decimal: 32  Hex: 0xFACE  Binary: 0b11001111",13,10
C105: 20 20 3E 20 49 4E 46 4F 0D 0A .byte "  > INFO",13,10
C10F: 20 20 36 38 42 30 39 20 53 42 43 20 4D 6F 6E 69 74 6F 72 20 76 31 2E 30 0D 0A .byte "  68B09 SBC Monitor v1.0",13,10
C129: 20 20 3E 20 48 45 4C 50 0D 0A .byte "  > HELP",13,10
C133: 20 20 28 73 68 6F 77 20 74 68 69 73 20 68 65 6C 70 29 0D 0A .byte "  (show this help)",13,10
C147: 20 20 3E 20 50 45 45 4B 20 31 30 30 0D 0A .byte "  > PEEK 100",13,10
C155: 20 20 42 42 0D 0A .byte "  BB",13,10
C15B: 20 20 3E 20 50 45 45 4B 20 31 30 30 20 34 0D 0A .byte "  > PEEK 100 4",13,10
C16B: 20 20 42 42 2C 20 32 32 2C 20 42 42 2C 20 32 32 0D 0A .byte "  BB, 22, BB, 22",13,10
C17D: 20 20 3E 20 50 4F 4B 45 20 31 30 30 20 32 0D 0A .byte "  > POKE 100 2",13,10
C18D: 20 20 4F 4B 0D 0A .byte "  OK",13,10
C193: 20 20 3E 20 50 4F 4B 45 20 31 30 30 20 32 20 30 78 34 35 20 30 62 31 31 5F 30 30 5F 31 31 31 31 0D 0A .byte "  > POKE 100 2 0x45 0b11_00_1111",13,10
C1B5: 20 20 4F 4B 0D 0A .byte "  OK",13,10
C1BB: 20 20 3E 20 4C 4F 41 44 20 31 30 30 20 34 0D 0A .byte "  > LOAD 100 4",13,10
C1CB: 20 20 43 48 45 43 4B 53 55 4D 3A 20 30 30 43 36 0D 0A .byte "  CHECKSUM: 00C6",13,10
C1DD: 20 20 3E 20 44 55 4D 50 20 30 78 34 30 30 35 20 31 38 0D 0A .byte "  > DUMP 0x4005 18",13,10
C1F1: 20 20 20 20 20 20 20 20 20 30 20 20 31 20 20 32 20 20 33 20 20 34 20 20 35 20 20 36 20 20 37 20 20 38 20 20 39 20 20 41 20 20 42 20 20 43 20 20 44 20 20 45 20 20 46 20 7C 20 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 0D 0A .byte "         0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | 0123456789ABCDEF",13,10
C23D: 20 20 34 30 30 30 3A 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 34 35 20 45 44 20 38 45 20 34 30 20 34 39 20 42 44 20 34 35 20 41 42 20 38 45 20 34 30 20 39 41 20 7C 20 20 20 20 20 20 45 2E 2E 40 49 2E 45 2E 2E 40 2E 0D 0A .byte "  4000:                45 ED 8E 40 49 BD 45 AB 8E 40 9A |      E..@I.E..@.",13,10
C289: 20 20 34 30 31 30 3A 20 42 44 20 34 35 20 41 42 20 42 44 20 34 35 20 32 46 20 42 46 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 7C 20 2E 45 2E 2E 45 2F 2E 0D 0A .byte "  4010: BD 45 AB BD 45 2F BF                            | .E..E/.",13,10
C2CC: 20 20 3E 20 45 58 45 43 20 31 30 30 0D 0A .byte "  > EXEC 100",13,10
C2DA: 20 20 42 59 45 0D 0A .byte "  BYE",13,10
C2E1: 00               .byte 0
                  
                  CommandList:
C2E2: 49 4E 46 4F 00   .byte "INFO",0
C2E7: C4 4F            .word CMD_INFO
C2E9: 48 45 4C 50 00   .byte "HELP",0
C2EE: C4 56            .word CMD_HELP
C2F0: 50 45 45 4B 00   .byte "PEEK",0
C2F5: C4 5D            .word CMD_PEEK
C2F7: 44 55 4D 50 00   .byte "DUMP",0
C2FC: C5 A1            .word CMD_DUMP
C2FE: 50 4F 4B 45 00   .byte "POKE",0
C303: C4 A3            .word CMD_POKE
C305: 45 58 45 43 00   .byte "EXEC",0
C30A: C5 2A            .word CMD_EXEC
C30C: 4C 4F 41 44 00   .byte "LOAD",0
C311: C4 D0            .word CMD_LOAD
C313: 46 49 4C 4C 00   .byte "FILL",0
C318: C5 51            .word CMD_FILL
                  EndOfCommandList:
                  
                  PROMPT:
C31A: 3E 20 00         .byte "> ",0
                  STR_DUMP_HEAD:
C31D: 20 20 20 20 20 20 20 30 20 20 31 20 20 32 20 20 33 20 20 34 20 20 35 20 20 36 20 20 37 20 20 38 20 20 39 20 20 41 20 20 42 20 20 43 20 20 44 20 20 45 20 20 46 20 7C 20 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 0D 0A 00 .byte "       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | 0123456789ABCDEF",13,10,0
                  ERR_NOT_IMPLEMENTED:
C368: 2A 2A 20 4E 4F 54 20 49 4D 50 4C 45 4D 45 4E 54 45 44 20 2A 2A 0D 0A 00 .byte "** NOT IMPLEMENTED **",13,10,0
                  ERR_UNKNOWN:
C380: 2A 2A 20 55 4E 4B 4E 4F 57 4E 20 43 4F 4D 4D 41 4E 44 20 2A 2A 0D 0A 00 .byte "** UNKNOWN COMMAND **",13,10,0
                  ERR_INVALID_BYTE:
C398: 2A 2A 20 49 4E 56 41 4C 49 44 20 42 59 54 45 3A 20 00 .byte "** INVALID BYTE: ",0
                  ERR_INVALID_WORD:
C3AA: 2A 2A 20 49 4E 56 41 4C 49 44 20 57 4F 52 44 3A 20 00 .byte "** INVALID WORD: ",0
                  ERR_END:
C3BC: 20 2A 2A 0D 0A 00 .byte " **",13,10,0
                  COMMA:
C3C2: 2C 20 00         .byte ", ",0
                  STR_OK:
C3C5: 4F 4B 0D 0A 00   .byte "OK",13,10,0
                  ERR_TOO_MANY:
C3CA: 2A 2A 20 54 4F 4F 20 4D 41 4E 59 20 50 41 52 41 4D 45 54 45 52 53 20 2A 2A 0D 0A 00 .byte "** TOO MANY PARAMETERS **",13,10,0
                  ERR_NOT_ENOUGH:
C3E6: 2A 2A 20 4E 4F 54 20 45 4E 4F 55 47 48 20 50 41 52 41 4D 45 54 45 52 53 20 2A 2A 0D 0A 00 .byte "** NOT ENOUGH PARAMETERS **",13,10,0
                  STR_CHK:
C404: 43 48 45 43 4B 53 55 4D 3A 20 00 .byte "CHECKSUM: ",0
                  STR_BYE:
C40F: 42 59 45 0D 0A 00 .byte "BYE",13,10,0
                  STR_BACK:
C415: 42 41 43 4B 0D 0A 00 .byte "BACK",13,10,0
                  STR_COLON:
C41C: 3A 20 00         .byte ": ",0
                  STR_SEP:
C41F: 7C 20 00         .byte "| ",0
                  
                  ErrInvalidByte:
C422: 34 10            PSHS   X                 ; Hold the pointer to the value
C424: 8E C3 98         LDX    #ERR_INVALID_BYTE ; Print the ...
C427: BD C8 24         JSR    PrintStr          ; ... "INVALID: "
                  ErrInvalidCom:
C42A: 35 10            PULS   X                 ; Restore pointer to value
C42C: BD C8 24         JSR    PrintStr          ; Print the value
C42F: 8E C3 BC         LDX    #ERR_END          ; Print the ...
C432: BD C8 24         JSR    PrintStr          ; ... end of the error message
C435: 39               RTS
                  
                  ErrInvalidWord:
C436: 34 10            PSHS   X                 ; Hold the pointer to the value
C438: 8E C3 AA         LDX    #ERR_INVALID_WORD ; Print the ...
C43B: BD C8 24         JSR    PrintStr          ; ... "INVALID"
C43E: 7E C4 2A         JMP    ErrInvalidCom     ; Print the end value and the end of the message
                  
                  ErrTooMany:
C441: 8E C3 CA         LDX    #ERR_TOO_MANY     ; Print the ...
C444: BD C8 24         JSR    PrintStr          ; ... error message
C447: 39               RTS
                  
                  ErrNotEnough:
C448: 8E C3 E6         LDX    #ERR_NOT_ENOUGH   ; Print the ...
C44B: BD C8 24         JSR    PrintStr          ; ... error message
C44E: 39               RTS
                  
                  CMD_INFO:
C44F: 8E C0 49         LDX    #STR_INFO         ; Print the ...
C452: BD C8 24         JSR    PrintStr          ; ... monitor info
C455: 39               RTS
                  
                  CMD_HELP:
C456: 8E C0 62         LDX    #STR_HELP         ; Print the ...
C459: BD C8 24         JSR    PrintStr          ; ... help string
C45C: 39               RTS
                  
                  CMD_PEEK:
                  ; PEEK 0x100 [1]
C45D: BD C7 8D         JSR    FindNextToken     ; Get the address
C460: 27 E6            BEQ    ErrNotEnough      ; Error if not given
C462: BD C6 71         JSR    ParseWord         ; Parse the address
C465: 26 CF            BNE    ErrInvalidWord    ; Error if invalid
C467: FC 7F 03         LDD    VALUE_UPPER       ; Hold the ...
C46A: FD 7F 08         STD    TMP2              ; ... address
C46D: C6 01            LDB    #1                ; Default number ...
C46F: F7 7F 0A         STB    TMP3              ; ... of peeks
C472: BD C7 8D         JSR    FindNextToken     ; Get the count
C475: 27 10            BEQ    CMDPEEK01         ; No count ... use default
C477: BD C6 5D         JSR    ParseByte         ; Yes ... parse the count
C47A: 26 A6            BNE    ErrInvalidByte    ; Error if invalid
C47C: F6 7F 04         LDB    VALUE_LOWER       ; Get the ...
C47F: F7 7F 0A         STB    TMP3              ; Peek count
C482: BD C7 8D         JSR    FindNextToken     ; Is there another parameter?
C485: 26 BA            BNE    ErrTooMany        ; Yes ... error
                  CMDPEEK01:
C487: 10 BE 7F 08      LDY    TMP2              ; Y has the address
C48B: F6 7F 0A         LDB    TMP3              ; B has the count
                  CMDPEEK02:
C48E: A6 A0            LDA    ,Y+               ; Get the value from memory
C490: BD C8 45         JSR    PrintByte         ; Print it on the screen
C493: 5A               DECB                     ; All done?
C494: 27 09            BEQ    CMDPEEKdone       ; Yes ... out
C496: 8E C3 C2         LDX    #COMMA            ; Print the ...
C499: BD C8 24         JSR    PrintStr          ; ... ", "
C49C: 7E C4 8E         JMP    CMDPEEK02         ; Do all peeks
                  CMDPEEKdone:
C49F: BD C8 31         JSR    PrintCRLF         ; CRLF
C4A2: 39               RTS
                  
                  CMD_POKE:
                  ; POKE 100 55 [2 4 20 8]
C4A3: BD C7 8D         JSR    FindNextToken     ; Get the address
C4A6: 27 A0            BEQ    ErrNotEnough      ; Error if not given
C4A8: BD C6 71         JSR    ParseWord         ; Parse the address
C4AB: 10 26 FF 87      LBNE   ErrInvalidWord    ; Error if invalid
C4AF: 10 BE 7F 03      LDY    VALUE_UPPER       ; Get the address
C4B3: BD C7 8D         JSR    FindNextToken     ; Get the 1st poke
C4B6: 27 90            BEQ    ErrNotEnough      ; Error if not given
                  PokeMore:
C4B8: BD C6 5D         JSR    ParseByte         ; Parse ...
C4BB: 10 26 FF 77      LBNE   ErrInvalidWord    ; ... the value
C4BF: B6 7F 04         LDA    VALUE_LOWER       ; Store ...
C4C2: A7 A0            STA    ,Y+               ; ... the value
C4C4: BD C7 8D         JSR    FindNextToken     ; Next token (if any)
C4C7: 26 EF            BNE    PokeMore          ; There is another ... go back
C4C9: 8E C3 C5         LDX    #STR_OK           ; Print ...
C4CC: BD C8 24         JSR    PrintStr          ; ... "OK"
C4CF: 39               RTS
                  
                  CMD_LOAD:
                  ; LOAD 0x100 512
                  ;   ..... data .....
C4D0: BD C7 8D         JSR    FindNextToken     ; Get the address
C4D3: 10 27 FF 71      LBEQ   ErrNotEnough      ; Error if not given
C4D7: BD C6 71         JSR    ParseWord         ; Parse the address
C4DA: 10 26 FF 58      LBNE   ErrInvalidWord    ; Error if invalid
C4DE: FE 7F 03         LDU    VALUE_UPPER       ; Get the address
C4E1: BD C7 8D         JSR    FindNextToken     ; Get the length
C4E4: 10 27 FF 60      LBEQ   ErrNotEnough      ; Error if not given
C4E8: BD C6 71         JSR    ParseWord         ; Parse the length
C4EB: 10 26 FF 47      LBNE   ErrInvalidWord    ; Error if invalid
C4EF: 10 BE 7F 03      LDY    VALUE_UPPER       ; Get the length
C4F3: 10 8C 00 00      CMPY   #0                ; There must ...
C4F7: 10 27 FF 3B      LBEQ   ErrInvalidWord    ; ... be at least one
C4FB: BD C7 8D         JSR    FindNextToken     ; Make sure there are ...
C4FE: 10 26 FF 3F      LBNE   ErrTooMany        ; ... no more input tokens
C502: 7F 7F 08         CLR    TMP2              ; Clear the ...
C505: 7F 7F 09         CLR    TMP2+1            ; ... checksum
                  LOAD1:
C508: BD C8 71         JSR    UARTRead          ; Get the data byte
C50B: A7 C0            STA    ,U+               ; Store it to memory
C50D: 1F 89            TFR    A,B               ; To LSB of D
C50F: 4F               CLRA                     ; MSB of D to 0
C510: F3 7F 08         ADDD   TMP2              ; Add to ...
C513: FD 7F 08         STD    TMP2              ; ... checksum
C516: 31 3F            LEAY   -1,Y              ; Do ...
C518: 26 EE            BNE    LOAD1             ; ... all
C51A: 8E C4 04         LDX    #STR_CHK          ; Print ...
C51D: BD C8 24         JSR    PrintStr          ; ... the ...
C520: FC 7F 08         LDD    TMP2              ; ... ...
C523: BD C8 3C         JSR    PrintWord         ; ... ...
C526: BD C8 31         JSR    PrintCRLF         ; ... checksum
C529: 39               RTS
                  
                  CMD_EXEC:
                  ; EXEC 0x100
C52A: BD C7 8D         JSR    FindNextToken     ; Get the address
C52D: 10 27 FF 17      LBEQ   ErrNotEnough      ; Error if not given
C531: BD C6 71         JSR    ParseWord         ; Parse the address
C534: 10 26 FE FE      LBNE   ErrInvalidWord    ; Error if invalid
C538: BD C7 8D         JSR    FindNextToken     ; Make sure there are ...
C53B: 10 26 FF 02      LBNE   ErrTooMany        ; ... no more tokens
C53F: 8E C4 0F         LDX    #STR_BYE          ; Tell the user ...
C542: BD C8 24         JSR    PrintStr          ; ... we are leaving
C545: BE 7F 03         LDX    VALUE_UPPER       ; Get the address
C548: AD 84            JSR    ,X                ; Call it
C54A: 8E C4 15         LDX    #STR_BACK         ; Tell the user ...
C54D: BD C8 24         JSR    PrintStr          ; ... we are back
C550: 39               RTS
                  
                  CMD_FILL:
                  ; FILL 0x100 512 00
C551: BD C7 8D         JSR    FindNextToken     ; Get the address
C554: 10 27 FE F0      LBEQ   ErrNotEnough      ; Error if not given
C558: BD C6 71         JSR    ParseWord         ; Parse the address
C55B: 10 26 FE D7      LBNE   ErrInvalidWord    ; Error if invalid
C55F: FE 7F 03         LDU    VALUE_UPPER       ; Get the address
C562: BD C7 8D         JSR    FindNextToken     ; Get the length
C565: 10 27 FE DF      LBEQ   ErrNotEnough      ; Error if not given
C569: BD C6 71         JSR    ParseWord         ; Parse the length
C56C: 10 26 FE C6      LBNE   ErrInvalidWord    ; Error if invalid
C570: 10 BE 7F 03      LDY    VALUE_UPPER       ; Get the length
C574: 10 8C 00 00      CMPY   #0                ; There must ...
C578: 10 27 FE BA      LBEQ   ErrInvalidWord    ; ... be at least one
C57C: BD C7 8D         JSR    FindNextToken     ; Get the value
C57F: 10 27 FE C5      LBEQ   ErrNotEnough      ; Error if not given
C583: BD C6 5D         JSR    ParseByte         ; Parse ...
C586: 10 26 FE 98      LBNE   ErrInvalidByte    ; ... the value
C58A: BD C7 8D         JSR    FindNextToken     ; Make sure ...
C58D: 10 26 FE B0      LBNE   ErrTooMany        ; ... there are no more
C591: B6 7F 04         LDA    VALUE_LOWER       ; The fill value
                  FILL1:
C594: A7 C0            STA    ,U+               ; Fill ...
C596: 31 3F            LEAY   -1,Y              ; ... the ...
C598: 26 FA            BNE    FILL1             ; ... memory chunk
C59A: 8E C3 C5         LDX    #STR_OK           ; Print ...
C59D: BD C8 24         JSR    PrintStr          ; ... "OK"
C5A0: 39               RTS
                  
                  CMD_DUMP:
                  ; DUMP 0x105 16
                  ;       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | 0123456789ABCDEF
                  ; 0100 -- -- -- -- -- 10 55 BF C8 00 00 00 DE 21 45 90 |      ..AB0...Y.*
                  ; 0110 A0 A2 B6 00 83 -- -- -- -- -- -- -- -- -- -- -- | UyXK.
C5A1: BD C7 8D         JSR    FindNextToken     ; Get the address
C5A4: 10 27 FE A0      LBEQ   ErrNotEnough      ; Error if not given
C5A8: BD C6 71         JSR    ParseWord         ; Parse the address
C5AB: 10 26 FE 87      LBNE   ErrInvalidWord    ; Error if invalid
C5AF: FE 7F 03         LDU    VALUE_UPPER       ; Get the address
C5B2: BD C7 8D         JSR    FindNextToken     ; Get the length
C5B5: 10 27 FE 8F      LBEQ   ErrNotEnough      ; Error if not given
C5B9: BD C6 71         JSR    ParseWord         ; Parse the length
C5BC: 10 26 FE 76      LBNE   ErrInvalidWord    ; Error if invalid
C5C0: 10 BE 7F 03      LDY    VALUE_UPPER       ; Get the length
C5C4: 10 8C 00 00      CMPY   #0                ; There must ...
C5C8: 10 27 FE 6A      LBEQ   ErrInvalidWord    ; ... be at least one
C5CC: BD C7 8D         JSR    FindNextToken     ; Get the value
C5CF: 10 26 FE 75      LBNE   ErrNotEnough      ; Error too many
C5D3: 8E C3 1D         LDX    #STR_DUMP_HEAD    ; Print the ...
C5D6: BD C8 24         JSR    PrintStr          ; ... header
                  
C5D9: FF 7F 06         STU    TMP1              ; Hold the starting point
C5DC: 10 BF 7F 08      STY    TMP2              ; Hold the length
C5E0: 1F 30            TFR    U,D               ; Hold ...
C5E2: F3 7F 08         ADDD   TMP2              ; ... the ...
C5E5: FD 7F 0A         STD    TMP3              ; ... end point
C5E8: 1F 30            TFR    U,D               ; Start on ...
C5EA: 5F               CLRB                     ; ... 16 byte ...
C5EB: 1F 03            TFR    D,U               ; ... boundary
                  
                  ; Clear the ASCII output buffer
                  DUMP0:
C5ED: 8E 7E 00         LDX    #BUFFER           ; ASCII dump buffer
C5F0: C6 10            LDB    #16               ; 16 to clear in buffer
C5F2: 86 20            LDA    #0x20             ; Space
                  DUMP1:
C5F4: A7 80            STA    ,X+               ; Clear ...
C5F6: 5A               DECB                     ; ... the ascii ...
C5F7: 26 FB            BNE    DUMP1             ; ... dump buffer
C5F9: 4F               CLRA                     ; null terminate ...
C5FA: A7 84            STA    ,X                ; ... dump buffer
C5FC: 1F 30            TFR    U,D               ; Print the ...
C5FE: BD C8 3C         JSR    PrintWord         ; ... address of the line
C601: 8E C4 1C         LDX    #STR_COLON        ; Print the ...
C604: BD C8 24         JSR    PrintStr          ; ... colon after address
                  
C607: 10 8E 7E 00      LDY    #BUFFER           ; Pointer into dump buffer
C60B: C6 10            LDB    #16               ; 16 bytes on this line
                  DUMP2:
C60D: 11 B3 7F 06      CMPU   TMP1              ; Are we before the requested data?
C611: 25 3C            BLO    DUMPspace         ; Yes ... print spaces
C613: 11 B3 7F 0A      CMPU   TMP3              ; Are we after the requested data?
C617: 24 36            BHS    DUMPspace         ; Yes ... print spaces
C619: A6 C0            LDA    ,U+               ; Get the value from memory
C61B: 81 20            CMPA   #0x20             ; Too low to print?
C61D: 25 0B            BLO    DUMPascdot        ; Yes ... use a dot
C61F: 81 7E            CMPA   #0x7E             ; Too high to print?
C621: 22 07            BHI    DUMPascdot        ; Yes ... use a dot
C623: A7 A0            STA    ,Y+               ; Store the character in the dump buffer
C625: BD C8 45         JSR    PrintByte         ; Print the 2 digit hex
C628: 20 07            BRA    DUMP3             ; Continue with next
                  DUMPascdot:
C62A: BD C8 45         JSR    PrintByte         ; Print the 2 digit hex
C62D: 86 2E            LDA    #0x2E             ; Store a dot to represent ...
C62F: A7 A0            STA    ,Y+               ; ... this unprintable
                  DUMP3:
C631: 86 20            LDA    #0x20             ; Space between ...
C633: BD C8 7B         JSR    UARTWrite         ; ... bytes
C636: 5A               DECB                     ; Do all ...
C637: 26 D4            BNE    DUMP2             ; ... 16 on this row
C639: 8E C4 1F         LDX    #STR_SEP          ; Print the separator ...
C63C: BD C8 24         JSR    PrintStr          ; ... before the dump buffer
C63F: 8E 7E 00         LDX    #BUFFER           ; Print the ascii ...
C642: BD C8 24         JSR    PrintStr          ; ... dump buffer
C645: BD C8 31         JSR    PrintCRLF         ; Next line
                  
C648: 11 B3 7F 0A      CMPU   TMP3              ; Have we reached the end?
C64C: 25 9F            BLO    DUMP0             ; No ... do more lines
C64E: 39               RTS
                  
                  DUMPspace:
C64F: 33 41            LEAU   1,U               ; Next in memory
C651: 31 21            LEAY   1,Y               ; Next in the dump buffer
C653: 86 20            LDA    #0x20             ; Print ...
C655: BD C8 7B         JSR    UARTWrite         ; ... two ...
C658: BD C8 7B         JSR    UARTWrite         ; ... spaces
C65B: 20 D4            BRA    DUMP3             ; Continue with the line
                  
                  ParseByte:
                  ; X is the buffer
C65D: BD C6 71         JSR    ParseWord         ; Parse the value
C660: 26 0E            BNE    PBY1              ; Check for errors
C662: FC 7F 03         LDD    VALUE_UPPER       ; Is the value ...
C665: 10 83 00 FF      CMPD   #255              ; ... larger than a byte?
C669: 10 22 00 E9      LBHI   ParseBad          ; Yes ... error
C66D: 16 00 E9         LBRA   ParseGood         ; No ... OK
                  PBY1:
C670: 39               RTS
                  
                  ParseWord:
                  ; X is the buffer
C671: 34 10            PSHS   X                 ; Hold pointer to token
C673: A6 84            LDA    ,X                ; Get the ...
C675: E6 01            LDB    1,X               ; ... first two characters
C677: 10 83 30 58      CMPD   #0x3058           ; "0X" ?
C67B: 26 07            BNE    PW1               ; No ... check for binary
C67D: 30 02            LEAX   2,X               ; Skip the base marker
C67F: BD C6 96         JSR    ParseHex          ; Parse hex value
C682: 35 90            PULS   X,PC              ; Restore token
                  PW1:
C684: 10 83 30 42      CMPD   #0x3042           ; "0B" ?
C688: 26 07            BNE    PW2               ; No ... do decimal
C68A: 30 02            LEAX   2,X               ; Skip the base marker
C68C: BD C7 5C         JSR    ParseBinary       ; Parse binary value
C68F: 35 90            PULS   X,PC              ; Restore token
                  PW2:
C691: BD C6 F6         JSR    ParseDecimal      ; Must be a decimal value
C694: 35 90            PULS   X,PC              ; Restore token
                  
                  ParseHex:
C696: 7F 7F 02         CLR    VALUE_OVERFLOW    ; Start ...
C699: 7F 7F 03         CLR    VALUE_UPPER       ; ... with ...
C69C: 7F 7F 04         CLR    VALUE_LOWER       ; ... value = 0
                  PH1:
C69F: A6 80            LDA    ,X+               ; Next text input
C6A1: 10 27 00 B4      LBEQ   ParseGood         ; End of token ... we have the value
C6A5: 81 5F            CMPA   #0x5F             ; Ignore ...
C6A7: 27 F6            BEQ    PH1               ; ... underscores
C6A9: 81 41            CMPA   #65               ; Letters A-F?
C6AB: 24 10            BHS    PHletts           ; Yes ... go do those
C6AD: 81 30            CMPA   #0x30             ; Too low?
C6AF: 10 25 00 A3      LBLO   ParseBad          ; Yes ... not a valid digit
C6B3: 81 39            CMPA   #0x39             ; Too high?
C6B5: 10 22 00 9D      LBHI   ParseBad          ; Yes ... not a valid digit
C6B9: 80 30            SUBA   #0x30             ; ASCII to number
C6BB: 20 08            BRA    PHdo
                  PHletts:
C6BD: 81 46            CMPA   #70               ; Too high?
C6BF: 10 22 00 93      LBHI   ParseBad          ; Yes ... not a valid digit
C6C3: 80 37            SUBA   #65-10            ; ASCII to number (+10)
                  PHdo:
C6C5: 78 7F 04         ASL    VALUE_LOWER       ; Now multiplied ...
C6C8: 79 7F 03         ROL    VALUE_UPPER       ; ... by ...
C6CB: 79 7F 02         ROL    VALUE_OVERFLOW    ; ... 2
C6CE: 78 7F 04         ASL    VALUE_LOWER       ; Now multiplied ...
C6D1: 79 7F 03         ROL    VALUE_UPPER       ; ... by ...
C6D4: 79 7F 02         ROL    VALUE_OVERFLOW    ; ... 4
C6D7: 78 7F 04         ASL    VALUE_LOWER       ; Now multiplied ...
C6DA: 79 7F 03         ROL    VALUE_UPPER       ; ... by ...
C6DD: 79 7F 02         ROL    VALUE_OVERFLOW    ; ... 8
C6E0: 78 7F 04         ASL    VALUE_LOWER       ; Now multiplied ...
C6E3: 79 7F 03         ROL    VALUE_UPPER       ; ... by ...
C6E6: 79 7F 02         ROL    VALUE_OVERFLOW    ; ... 16
C6E9: 7D 7F 02         TST    VALUE_OVERFLOW    ; Handle ...
C6EC: 26 68            BNE    ParseBad          ; ... overflows
C6EE: BB 7F 04         ADDA   VALUE_LOWER       ; Add in the ...
C6F1: B7 7F 04         STA    VALUE_LOWER       ; ... new lower digit
C6F4: 20 A9            BRA    PH1               ; Continue
                  
                  ParseDecimal:
C6F6: 7F 7F 02         CLR    VALUE_OVERFLOW    ; Start ...
C6F9: 7F 7F 03         CLR    VALUE_UPPER       ; ... with ...
C6FC: 7F 7F 04         CLR    VALUE_LOWER       ; ... value = 0
                  PD1:
C6FF: A6 80            LDA    ,X+               ; Next text input
C701: 27 56            BEQ    ParseGood         ; End of token ... we have the value
C703: 81 5F            CMPA   #0x5F             ; Ignore ...
C705: 27 F8            BEQ    PD1               ; ... underscores
                  ; Check the value and convert from ASCII
C707: 81 30            CMPA   #0x30             ; Too low?
C709: 25 4B            BLO    ParseBad          ; Yes ... not a valid digit
C70B: 81 39            CMPA   #0x39             ; Too high?
C70D: 22 47            BHI    ParseBad          ; Yes ... not a valid digit
C70F: 80 30            SUBA   #0x30             ; ASCII to number
                  ; Multiply value by 10
C711: B7 7F 06         STA    TMP1              ; Hold the new digit number
C714: FC 7F 03         LDD    VALUE_UPPER       ; Hold the value to add for *5
                  ;
C717: 78 7F 04         ASL    VALUE_LOWER       ; Now multiplied ...
C71A: 79 7F 03         ROL    VALUE_UPPER       ; ... by ...
C71D: 79 7F 02         ROL    VALUE_OVERFLOW    ; ... 2
                  ;
C720: 78 7F 04         ASL    VALUE_LOWER       ; Now multiplied ...
C723: 79 7F 03         ROL    VALUE_UPPER       ; ... by ...
C726: 79 7F 02         ROL    VALUE_OVERFLOW    ; ... 4
                  ;
C729: 1C FE            ANDCC  #0b11111110       ; Clear the carry
C72B: F9 7F 04         ADCB   VALUE_LOWER       ; Add to original to ...
C72E: B9 7F 03         ADCA   VALUE_UPPER       ; ... make times 5
C731: 79 7F 02         ROL    VALUE_OVERFLOW    ; Shift any carry into the overflow
C734: FD 7F 03         STD    VALUE_UPPER       ; Now times 5
                  ;
C737: 78 7F 04         ASL    VALUE_LOWER       ; Now multiplied ...
C73A: 79 7F 03         ROL    VALUE_UPPER       ; ... by ...
C73D: 79 7F 02         ROL    VALUE_OVERFLOW    ; ... 10
                  ;
C740: 7D 7F 02         TST    VALUE_OVERFLOW    ; Catch overflows ...
C743: 26 11            BNE    ParseBad          ; ... from the multiply
                  ; Add in the new lower digit
C745: 4F               CLRA                     ; The new ...
C746: F6 7F 06         LDB    TMP1              ; ... lower digit
C749: 1C FE            ANDCC  #0b11111110       ; Clear the carry
C74B: F9 7F 04         ADCB   VALUE_LOWER       ; Add in ...
C74E: B9 7F 03         ADCA   VALUE_UPPER       ; ... the new lower digit
C751: FD 7F 03         STD    VALUE_UPPER       ; The new value
C754: 24 A9            BCC    PD1               ; Catch overflow or keep going
                  ParseBad:
C756: 1C FB            ANDCC  #0b11111011       ; Z=0 ... BAD VALUE
C758: 39               RTS
                  ParseGood:
C759: 1A 04            ORCC   #0b00000100       ; Z=1 ... GOOD VALUE
C75B: 39               RTS
                  
                  ParseBinary:
C75C: 7F 7F 02         CLR    VALUE_OVERFLOW    ; Start ...
C75F: 7F 7F 03         CLR    VALUE_UPPER       ; ... with ...
C762: 7F 7F 04         CLR    VALUE_LOWER       ; ... value = 0
                  PB1:
C765: A6 80            LDA    ,X+               ; Next text input
C767: 27 F0            BEQ    ParseGood         ; End of token ... we have the value
C769: 81 5F            CMPA   #0x5F             ; Ignore ...
C76B: 27 F8            BEQ    PB1               ; ... underscores
                  ; Check the value and convert from ASCII
C76D: 81 30            CMPA   #0x30             ; Too low?
C76F: 25 E5            BLO    ParseBad          ; Yes ... not a valid digit
C771: 81 31            CMPA   #0x31             ; Too high?
C773: 22 E1            BHI    ParseBad          ; Yes ... not a valid digit
C775: 80 30            SUBA   #0x30             ; ASCII to number
C777: 78 7F 04         ASL    VALUE_LOWER       ; Now multiplied ...
C77A: 79 7F 03         ROL    VALUE_UPPER       ; ... by ...
C77D: 79 7F 02         ROL    VALUE_OVERFLOW    ; ... 2
C780: 7D 7F 02         TST    VALUE_OVERFLOW    ; Handle ...
C783: 26 D1            BNE    ParseBad          ; ... overflows
C785: BB 7F 04         ADDA   VALUE_LOWER       ; Add in the ...
C788: B7 7F 04         STA    VALUE_LOWER       ; ... new low bit
C78B: 20 D8            BRA    PB1               ; Do them all
                  
                  FindNextToken:
C78D: BC 7F 00         CMPX   END_OF_INPUT      ; End of buffer?
C790: 27 15            BEQ    FNT02             ; Return Z=1 ... no more
C792: A6 84            LDA    ,X                ; Find the end ...
C794: 27 04            BEQ    FNT01             ; ... of the ...
C796: 30 01            LEAX   1,X               ; ... current ...
C798: 20 F3            BRA    FindNextToken     ; ... token
                  FNT01:
C79A: BC 7F 00         CMPX   END_OF_INPUT      ; End of buffer?
C79D: 27 08            BEQ    FNT02             ; Return Z=1 ... no more
C79F: A6 84            LDA    ,X                ; Find the start ...
C7A1: 26 04            BNE    FNT02             ; ... of the ...
C7A3: 30 01            LEAX   1,X               ; ... next ...
C7A5: 20 F3            BRA    FNT01             ; ... token
                  FNT02:
C7A7: 39               RTS                      ; Done (Z=1 for NO MORE or Z=0 for FOUND)
                  
                  GetInput:
                  ; Read an input line from the UART. Echo back the chars to the UART.
                  ; Limit the buffer to 256 bytes. Don't backspace before beginning.
C7A8: 8E 7E 00         LDX    #BUFFER           ; Make ...
C7AB: 86 20            LDA    #0x20             ; ... a leading ...
C7AD: A7 80            STA    ,X+               ; ... space
                  InpMain:
C7AF: BD C8 71         JSR    UARTRead          ; Get the input character
C7B2: 81 0D            CMPA   #0x0D             ; Is this ENTER key?
C7B4: 26 0B            BNE    Inp01             ; No ... process it
C7B6: 6F 80            CLR    ,X+               ; Null terminate the buffer
C7B8: BD C8 7B         JSR    UARTWrite         ; Send a return
C7BB: 86 0A            LDA    #0x0A             ; Send a ...
C7BD: BD C8 7B         JSR    UARTWrite         ; ... new-line to terminal
C7C0: 39               RTS                      ; Done
                  Inp01:
C7C1: 81 08            CMPA   #0x08             ; Is this BACKSPACE?
C7C3: 26 0C            BNE    Inp02             ; No ... try others
C7C5: 8C 7E 01         CMPX   #BUFFER+1         ; Any characters to remove?
C7C8: 27 E5            BEQ    InpMain           ; No ... just ignore this
C7CA: 30 1F            LEAX   -1,X              ; Back up over last character
C7CC: BD C8 7B         JSR    UARTWrite         ; Echo the BACKSPACE on the terminal
C7CF: 20 DE            BRA    InpMain           ; Continue
                  Inp02:
C7D1: 8C 7E FF         CMPX   #BUFFER+255       ; Is the buffer full? (leaving space for trailing NULL)
C7D4: 27 D9            BEQ    InpMain           ; Yes ... ignore
C7D6: A7 80            STA    ,X+               ; Add the character to the buffer
C7D8: BD C8 7B         JSR    UARTWrite         ; Echo the character on the terminal
C7DB: 20 D2            BRA    InpMain           ; Continue
                  
                  PrepInput:
C7DD: 34 10            PSHS   X                 ; Hold X
C7DF: 8E 7E 00         LDX    #BUFFER           ; Start of buffer
                  PrepInput2:
C7E2: A6 80            LDA    ,X+               ; Next character of input
C7E4: 27 2F            BEQ    PrepInDone        ; Null terminator ... done
C7E6: 81 23            CMPA   #0x23             ; "#" comment?
C7E8: 26 09            BNE    PrepInput2b       ; No ... keep going
C7EA: 86 00            LDA    #0                ; Null terminate ...
C7EC: A7 1F            STA    -1,X              ; ... to here
C7EE: BF 7F 00         STX    END_OF_INPUT      ; Line ends at comment
C7F1: 20 22            BRA    PrepInDone        ; Done
                  PrepInput2b:
C7F3: 81 20            CMPA   #0x20             ; Is this a SPACE?
C7F5: 26 06            BNE    PrepInput1        ; No ... skip
C7F7: 86 00            LDA    #0                ; Turn spaces ...
C7F9: A7 1F            STA    -1,X              ; ... to nulls
C7FB: 20 E5            BRA    PrepInput2        ; Next character
                  PrepInput1:
C7FD: 81 2C            CMPA   #0x2C             ; Is this a comma?
C7FF: 26 06            BNE    PrepInput1b       ; No ... skip
C801: 86 00            LDA    #0                ; Turn commas ...
C803: A7 1F            STA    -1,X              ; ... to nulls
C805: 20 DB            BRA    PrepInput2        ; Next character
                  PrepInput1b:
C807: 81 61            CMPA   #0x61             ; Lower case "a"
C809: 25 D7            BLO    PrepInput2        ; Not a lower case letter ... continue
C80B: 81 7A            CMPA   #0x7A    ; "z"    ; Lower case "z"
C80D: 22 D3            BHI    PrepInput2        ; Not a lower case letter ... continue
C80F: 80 20            SUBA   #0x20             ; Convert lower to upper
C811: A7 1F            STA    -1,X              ; Replace lower with upper
C813: 20 CD            BRA    PrepInput2        ; Next character
                  PrepInDone:
C815: 35 90            PULS   X,PC              ; Restore X
                  
                  StrCompare:
                  ; Compare two strings pointed to by X and Y.
                  ; Return Z=1 if the same or Z=0 if different
C817: 34 30            PSHS   Y,X               ; Hold pointers
                  Next:
C819: A6 80            LDA    ,X+               ; Characters ...
C81B: A1 A0            CMPA   ,Y+               ; ... match?
C81D: 26 03            BNE    Done              ; No ... return with Z=0
C81F: 4D               TSTA                     ; Is this the end of the string?
C820: 26 F7            BNE    Next              ; No ... keep checking
                  ; Return with Z=1
                  Done:
C822: 35 B0            PULS    X,Y,PC
                  
                  PrintStr:
C824: 34 10            PSHS   X                 ; Hold X
                  PrintStr2:
C826: A6 80            LDA    ,X+               ; Next character from string
C828: 27 05            BEQ    PrintStr1         ; Null terminator ... done
C82A: BD C8 7B         JSR    UARTWrite         ; Print the character
C82D: 20 F7            BRA    PrintStr2         ; Do them all
                  PrintStr1:
C82F: 35 90            PULS   X,PC              ; Restore X
                  
                  PrintCRLF:
C831: 86 0D            LDA    #0x0D             ; Print the ...
C833: BD C8 7B         JSR    UARTWrite         ; ... CR
C836: 86 0A            LDA    #0x0A             ; Print the ...
C838: BD C8 7B         JSR    UARTWrite         ; ... LF
C83B: 39               RTS
                  
                  PrintWord:
C83C: BD C8 45         JSR    PrintByte         ; Print the upper 2 digits
C83F: 1F 98            TFR    B,A               ; Print ...
C841: BD C8 45         JSR    PrintByte         ; ... the lower 2 digits
C844: 39               RTS
                  
                  PrintByte:
C845: 34 02            PSHS   A                 ; Hold the lower digit
C847: 44               LSRA                     ; Print ...
C848: 44               LSRA                     ; ... the ...
C849: 44               LSRA                     ; ... upper ...
C84A: 44               LSRA                     ; ... ...
C84B: BD C8 54         JSR    PrintDigit        ; ... digit
C84E: 35 02            PULS   A                 ; Restore the lower
C850: BD C8 54         JSR    PrintDigit        ; Print the lower digit
C853: 39               RTS
                  
                  PrintDigit:
C854: 84 0F            ANDA   #0x0F             ; Just one digit
C856: 81 0A            CMPA   #10               ; Hex letter?
C858: 24 06            BHS    PD01              ; Yes ... go do that
C85A: 8B 30            ADDA   #0x30             ; No ... offset from ascii "0"
C85C: BD C8 7B         JSR    UARTWrite         ; Print the digit
C85F: 39               RTS
                  PD01:
C860: 8B 37            ADDA   #65-10            ; Offset from ascii "A"
C862: BD C8 7B         JSR    UARTWrite         ; Print the digit
C865: 39               RTS
                  
                  UARTInit:
                  ; 8N1@115200
C866: 86 07            LDA    #0x7              ; Master reset
C868: B7 A0 00         STA    ACI_CONTROL       ; Reset the UART
C86B: 86 15            LDA    #0x15             ; 8N1 + divide by 16
C86D: B7 A0 00         STA    ACI_CONTROL       ; Configure communications
C870: 39               RTS
                  
                  UARTRead:
                  ; Wait for a byte from the UART.
                  ; Return in A
C871: B6 A0 00         LDA    ACI_CONTROL       ; Data ...
C874: 44               LSRA                     ; ... available?
C875: 24 FA            BCC    UARTRead          ; No ... wait
C877: B6 A0 01         LDA    ACI_DATA          ; Get the data
C87A: 39               RTS
                  
                  UARTWrite:
                  ; Wait for UART to be ready.
                  ; Send byte to UART from A
C87B: 34 02            PSHS   A                 ; Hold the output value
                  WriteWait:
C87D: B6 A0 00         LDA    ACI_CONTROL       ; Buffer ...
C880: 44               LSRA                     ; ... is ...
C881: 44               LSRA                     ; ... full?
C882: 24 F9            BCC    WriteWait         ; Yes ... wait
C884: 35 02            PULS   A                 ; Restore the output value
C886: B7 A0 01         STA    ACI_DATA          ; Send the data
C889: 39               RTS
                  
                  ; When compiled to ROM
                  ;
                  0xFFF0:
FFF0: C0 00            .word Top
FFF2: C0 00            .word Top
FFF4: C0 00            .word Top
FFF6: C0 00            .word Top
FFF8: C0 00            .word Top
FFFA: C0 00            .word Top
FFFC: C0 00            .word Top
FFFE: C0 00            .word Top  ; RESET
